<HTML><HEAD><TITLE>Performance engineering from scratch</TITLE></HEAD>
<BODY>

<H2>Performance engineering from scratch</H2>

Points to cover:

<UL><LI>Performance theory
        <UL><LI>Big-O notation
                <UL><LI>Average upper bound for large n only</LI>
                    <LI>Lower order components</LI>
                    <LI>The constants</LI>
                    <LI>Worst-case scenario, and performance reliability</LI>
                    <LI>NP-completeness</LI>
                    <LI>Encryption depends on it</LI>
                </UL></LI>
            <LI><FONT color="grey">Turing machines and Turing complete - necessary?</FONT></LI>
            <LI><FONT color="grey">Halting problem - is this actually necessary?</FONT></LI>
            <LI>CPU architecture (more later, in Funky Stuff)</LI>
            <LI>Storage heirarchy and caches</LI>
            <LI>Specialised hardware</LI>
            <LI>Latency versus bandwidth</LI>
        </UL></LI>
    <LI>Algorithms
        <UL><LI>DSA</LI>
            <LI>Prime number algorithms</LI>
            <LI>Sorting algorithms
                <UL><LI>Stability</LI>
                    <LI>Bubble sort
                        <UL><LI>Knuth: "The bubble sort seems to have nothing to recommend it, except a catchy name and the fact that it leads to some interesting theoretical problems."</LI>
                            <LI>Hares and tortoises - Cocktail sort</LI>
                        </UL></LI>
                    <LI>Selection sort</LI>
                    <LI>Insertion sort
                        <UL><LI>Generally the fastest sort algorithm up to 70 items</LI>
                        </UL></LI>
                    <LI>Heapsort, and the heap data structure - variation on selection sort</LI>
                    <LI>Shell sort - variant on insertion sort</LI>
                    <LI>Quicksort</LI>
                    <LI>Merge sort</LI>
                    <LI>java.util.Arrays.sort()</LI>
                    <LI>Bucket sort</LI>
                    <LI>Using different algorithms for different size arrays</LI>
                    <LI>Spilling to disc</LI>
                </UL></LI>
            <LI>Lookup algorithms
                <UL><LI>Linear array search</LI>
                    <LI>Linear linked list search</LI>
                    <LI>Binary search
                        <UL><LI>http://www.tbray.org/ongoing/When/200x/2003/03/22/Binary</LI>
                            <LI>java.util.Arrays.binarySearch()</LI>
                        </UL></LI>
                    <LI>Tree search
                        <UL><LI>java.util.TreeSet/Map</LI>
                        </UL></LI>
                    <LI>Hash search
                        <UL><LI>java.util.HashSet/Map</LI>
                        </UL></LI>
                    <LI>Bitmap</LI>
                    <LI>Space efficiency gives performance due to caches</LI>
                </UL></LI>
            <LI>How hard is "a comparison"?
                <UL><LI>Strings - how does the length of the String affect tree/hash searches and sorting?</LI>
                </UL></LI>
            <LI>String concatenation
                <UL><LI>java.lang.StringBuffer</LI>
                    <LI>Memory efficiency and the "double when full" behaviour</LI>
                    <LI>Memory efficiency and org.intermine.util.StringConstructor</LI>
                </UL></LI>
            <LI><FONT color="grey">State machines as a programming method - is that performance-related?</FONT></LI>
            <LI>Inserting into an array - text editors, and the split array</LI>
        </UL></LI>
    <LI>Multi-threading and Multiple CPUs
        <UL><LI>Recap on serialisation (synchronisation)</LI>
            <LI>Thread-local variable copies</LI>
            <LI>ThreadLocal variables</LI>
            <LI>Mutex overhead</LI>
            <LI>Lock contention</LI>
            <LI>java.util.concurrent
                <UL><LI>ConcurrentHashMap</LI>
                    <LI>ConcurrentSkipListMap</LI>
                    <LI>ConcurrentSkipListSet</LI>
                    <LI>ConcurrentLinkedQueue</LI>
                </UL></LI>
            <LI>IO and worker threads model</LI>
        </UL></LI>
    <LI>Databases
        <UL><LI>Warning: Very complex subject</LI>
            <LI>Try to do all the work in the database</LI>
            <LI>Large queries have little overhead</LI>
            <LI>Algorithms used
                <UL><LI>Sequential scan</LI>
                    <LI>Index scan</LI>
                    <LI>Bitmap index scans</LI>
                    <LI>The limit of indexes - a &gt; x and b &lt; y</LI>
                    <LI>Nested loop joins</LI>
                    <LI>Hash table generation - hash joins</LI>
                    <LI>Merge joins</LI>
                    <LI>Sorting</LI>
                    <LI>Hash aggregation</LI>
                </UL></LI>
            <LI>Query planner</LI>
        </UL></LI>
    <LI>Reflection and avoiding it
        <UL><LI>Loading objects from databases, or deserialising XML</LI>
            <LI>Reflection is slow</LI>
            <LI>Hibernate method: Generate bytecode per class that accesses the setters</LI>
            <LI>InterMine method: Add extra methods to the classes</LI>
        </UL></LI>
    <LI>Funky stuff
        <UL><LI>CPU architecture
                <UL><LI>Branch prediction</LI>
                    <LI>Instruction pool</LI>
                    <LI>Speculative execution</LI>
                </UL></LI>
            <LI>Postgres - sequential scans use small set of buffers to stay in cache</LI>
            <LI>Linux 2.6.25 scheduler - avoid invalidating caches</LI>
            <LI>Linux anticipatory IO scheduler</LI>
            <LI>Postgres 8.3 - simultaneous sequential scans</LI>
            <LI>Postgres 8.3 - HOT</LI>
            <LI>Journalling and Postgres WAL</LI>
            <LI>Linux network stack hash table attacks - fill up one hash bucket. Solution: crypto hash codes, syncookies</LI>
            <LI>Everyone wakes up on a signal - Postgres ipc when the metadata update message queue is full</LI>
        </UL></LI>
</UL>
