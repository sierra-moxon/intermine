#!/usr/bin/perl

use strict;
use warnings;
use File::Find;
use File::Path;
use Cwd;

my $BIO_DIR = 'bio';
my $STRUCTURE_DIR = "$BIO_DIR/skeletons/source";

my $CUSTOM_FILE_TYPE = 'custom-file';
my $ITEMS_XML_FILE_TYPE = 'intermine-items-xml-file';
my $LARGE_ITEMS_XML_FILE_TYPE = 'intermine-items-large-xml-file';

sub custom_file_props;
sub xml_items_props;

my %project_properties = (
                          $CUSTOM_FILE_TYPE => \&custom_file_props,
                          $ITEMS_XML_FILE_TYPE => \&xml_items_props,
                          $LARGE_ITEMS_XML_FILE_TYPE => \&large_xml_items_props,
                         );

my $source_types = join "\n", map { ' ' x 20 . $_ } sort keys %project_properties;

if (@ARGV != 2) {
  usage (<<USAGE);
needs two arguments
USAGE
}

my $source_name = shift;
my $source_type = shift;

(my $camel_case_source_name = $source_name) =~ s/(\w)([^\-_]+)[_\-]?/\U$1\E$2/g;

sub custom_file_props
{
  return <<PROPS;
have.file.custom.tgt = true
converter.class = org.intermine.bio.dataconversion.${camel_case_source_name}Converter
PROPS
}

sub xml_items_props
{
  return <<PROPS;
have.file.xml.tgt = true
PROPS
}

sub large_xml_items_props
{
  return <<PROPS;
have.large.file.xml.tgt = true
PROPS
}

my $create_main = 1;

if ($source_type eq $ITEMS_XML_FILE_TYPE or $source_type eq $LARGE_ITEMS_XML_FILE_TYPE) {
  $create_main = 0;
}


sub usage
{
  my $message = shift;

  die <<"MESSAGE";
$0: $message
usage:
  $0 <source-name> <source-type>

<source-name> - the name of the directory to create in $BIO_DIR/sources
                eg. foobase-gene-data
<source-type> - possible source types are:
$source_types
MESSAGE
}

my @base_project_properties =
  qw(intermine/objectstore/main bio/core/main intermine/integrate/main);

my $project_dependencies = join ", \\\n           ", @base_project_properties;

if ($create_main) {
  $project_dependencies .= ", \\\n           bio/sources/${source_name}/main";
}

my %substitutions = (
                     'source-name' => $source_name,
                     'camel-case-source-name' => $camel_case_source_name,
                     'project-dependencies' => $project_dependencies
                    );

if (exists $project_properties{$source_type}) {
  $substitutions{'project-properties'} = &{$project_properties{$source_type}};
} else {
  usage ("unknown source type: $source_type");
}

# check that we're in the right part of checkout
if (!-d 'imbuild' || !-d 'intermine') {
  usage (<<MESSAGE);
need to run in the top level of an intermine checkout (containing
"imbuild" and "intermine")
MESSAGE
}

sub substitute
{
  my $text = shift;

  for my $subs_key (keys %substitutions) {
    $text =~ s/\$\{$subs_key\}/$substitutions{$subs_key}/;
  }

  return $text;
}

my $start_dir = getcwd;

sub starts_with_main
{
  my $path = shift;
  return $path =~ m:^main($|/):;
}

my $full_source_dir = "$start_dir/$BIO_DIR/sources/$source_name";

if (-e $full_source_dir) {
  usage(<<MESSAGE);
$full_source_dir already exists
MESSAGE

}

# substitute ${foo} sequences in file contents and in file names
sub process
{
  my $orig_path = "$start_dir/$File::Find::name";
  my $dest_path = $File::Find::name;

  $dest_path =~ s:$STRUCTURE_DIR/?::;

  if (!$create_main) {
    if (starts_with_main($dest_path)) {
      return;
    }
  }

  $dest_path = $full_source_dir . '/' . substitute($dest_path);

  if (-d $orig_path) {
    mkpath($dest_path);
  } else {
    open my $orig, '<', $orig_path or die "can't open $orig_path: $!\n";
    open my $dest, '>', $dest_path or die "can't open $dest_path: $!\n";

    while (my $line = <$orig>) {
      $line = substitute($line);

      print $dest $line;
    }

    close $orig or die "can't close $orig_path: $!\n";
    close $dest or die "can't close $dest_path: $!\n";
  }
}

sub preprocess
{
  return grep {$_ !~ /^(\.svn|.*~)$/} @_;
}

find({
      wanted => \&process, 
      preprocess => \&preprocess
     },
     $STRUCTURE_DIR);

warn "created $full_source_dir directory for $source_name\n";
