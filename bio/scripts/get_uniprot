#!/usr/bin/perl

# script to download the latest uniprot release into a directory like uniprot/5.3
# the version number is extracted from the relnotes.txt file on the FTP server
# the script should be run in /shared/data

use strict;
use warnings;

BEGIN {
  # find the lib directory by looking at the path to this script
  push (@INC, ($0 =~ m:(.*)/.*:)[0] . '/../../intermine/perl/lib/');
}
use InterMine::DataDownloader;

my @files_to_get = qw(
                      uniprot.xsd.gz uniprot_sprot.xml.gz uniprot_trembl.xml.gz
                     );
my $uniprot_address = "ftp.uniprot.org";
my $username = "anonymous";
my $password = "-anonymous\@";
my $uniprot_base_path = "pub/databases/uniprot/current_release";
my $uniprot_full_path = "$uniprot_base_path/knowledgebase/complete";
my $release_notes_file = "relnotes.txt";
my $uniprot_main_dir = "/shared/data/uniprot";
my $keywords_file = "keydef.xml.gz";

#### Access ftp server
my $connection = &ftp_connect($uniprot_address,$username,$password);

$connection->cwd($uniprot_base_path)
  or die "Cannot change working directory ", $connection->message;

#download the release notes file
my $local_release_notes_copy = "$uniprot_main_dir/$release_notes_file";
&ftp_download($connection,$uniprot_main_dir,$release_notes_file);

#get the uniprot version from the release notes file
my $version;
open F, $local_release_notes_copy
  or die "can't open local copy of relnotes.txt: $local_release_notes_copy\n";
while (my $line = <F>) {
  if ($line =~ /UniProt.*Release (\S+)/) {
  	#print "$line\n";
    $version = $1;
  }
}
close F;

if (!defined $version) {
  die "can't find version number in release notes\n";
}else{print "Version $version found\n";}

unlink $local_release_notes_copy;

#if there is a new release, download and unzip it, update the current link
my $download_dir = "$uniprot_main_dir/$version";
if(&checkdir_exists($download_dir)==1){
	$connection->cwd("/$uniprot_full_path")
		or die "Cannot change working directory ", $connection->message;

	for my $file_to_get (@files_to_get) {
	  &ftp_download($connection,$download_dir,$file_to_get);
	}
	
	#download keydefs.xml
	$connection->cwd("/$uniprot_full_path/docs")
		or die "Cannot change working directory ", $connection->message;
	&ftp_download($connection,$download_dir,$keywords_file);	
	&unzip_dir($download_dir);
	
	my $uniprot_link = "/shared/data/uniprot/current";
	&make_link($version,$uniprot_link);
}else{ 
	warn " current version up to date - skipping download\n";
}

system "chmod -R a+r,g+w $download_dir";
$connection->quit;

#============================================================================

#splits the uniprot xml files into separate files based on the ncbi taxon id. Reads the taxons of interest from a 
#centrally stored file.

my($start, $end, $buffer, $trigger) = ("<entry", "</entry>", '', 'type="NCBI Taxonomy"');
my ($filename, $fname_end);
my ($keep, $taxon) = ("false", '0000');
my (@new_contents, @old_contents);

#the xml declaration and root element for each output file			
my $prolog = '<?xml version="1.0" encoding="UTF-8"?>
<uniprot xmlns="http://uniprot.org/uniprot"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://uniprot.org/uniprot http://www.uniprot.org/support/docs/uniprot.xsd">';
#define the last elements for each output file
my $element_end = '<copyright>
Copyrighted by the UniProt Consortium, see http://www.uniprot.org/terms
Distributed under the Creative Commons Attribution-NoDerivs License
</copyright>
</uniprot>';

my $split_dir = "/shared/data/uniprot/$version/split/";
if(&checkdir_exists($split_dir)==0){
	warn "Data already split.\n";
}else{
	print "Splitting files by taxon Id\n";
	#use hash to define output name for each source file
	#comment out one of them to process the other file only
	my %files = (
	             'sprot'  => { 	'filename' => "$download_dir/uniprot_sprot.xml", 
				 				'fname_end' => '_uniprot_sprot.xml'},
	             'trembl'  => { 'filename' => "$download_dir/uniprot_trembl.xml",
				 				'fname_end' => '_uniprot_trembl.xml'},
	             );		

	#open file to get taxonIDs from the config file
	my $config_file = "/shared/data/taxonID.config";
	my %taxons = &config_species($config_file,"uniprot");
	
	#open each uniprot file
	foreach my $file_type(sort keys %files){
		$filename = $files{$file_type}->{'filename'};
		$fname_end = $files{$file_type}->{'fname_end'};
			
		#read a line at a time and identify the start/stop/taxon id
		open(F,"<$filename") or die "$! was expecting something like uniprot_sprot.xml or uniprot_trembl.xml";
		while(my $newline = <F>){
			if($newline && $newline =~ /$start/gi){
				$keep = "true";
			}elsif($newline && $newline =~ /$trigger/gi){
				if($newline=~/id="(\d+)"/){
				$taxon = $1;
				}
			}elsif($newline && $newline =~ /$end/gi){
				$buffer .= $newline;
				if(exists $taxons{$taxon}){
					&writefile($buffer,$taxon,$fname_end);
				}
				$keep = "false";
				$buffer = "";
				$taxon = 0000;
			}	
			if($keep eq "true"){
				$buffer .= $newline;
			}
		}
	close(F) or die "$!";
	}

	#identify the output files
	opendir(DIR,$split_dir) || die("Cannot open directory !\n");
	@new_contents=grep(!/^\.\.?$/,readdir DIR);
	closedir(DIR);

	#add the copyright and close the root element to the output files
	foreach my $file (@new_contents){
		$file = $split_dir.$file;
		open( FILE, ">>$file") or die "cannot open $file: $!";
		print FILE "$element_end";
		close(FILE);
	}	
}

#creates files and adds elements as appropriate 
sub writefile(){
my ($xml,$species,$end) = @_;
my $new_file = $split_dir.$species.$end;

	if(!-e $new_file ){
		open(FH, ">$new_file") || die "$!";
		print FH "$prolog\n";
		print FH "$xml";
		close(FH);
	}else{
	open(FH, ">>$new_file") || die "$!";
		print FH "$xml";
		close(FH);
	}
}
















