#!/usr/bin/perl

# Run the FlyMine production build and dump the database occasionally
# Targets are listed at the end of the script
# The database to dump will be found by reading the properties from $HOME/<mine_name>.properties

use strict;
use warnings;

use Expect;
use Getopt::Std;
use Cwd;

use XML::Parser::PerlSAX;

my @ant_command = ("ant");

my $dump_file_prefix;
my $dump_host;
my $project_file = 'project.xml';

sub usage
{
  die <<"EOF";
usage:
  $0 [-v] [-l | -r] [-V version_number] dump_host dump_file_prefix

flags:
 -v is passed to ant
 -l attempt to restart by reading the last dump file
 -r attempt to restart just after the last dump point _without_ loading a dump
 -n parse files and report actions, but don't execute anything
 -V set the release number to pass to ant (as -Drelease=release_number)

example:
  $0 gollum /tmp/production_dump
EOF
}

if (!-f $project_file) {
  warn "can't find $project_file in the current directory\n";
  usage();
}

my $verbose = 0;
my $load_last = 0;
my $restart = 0;
my $dry_run = 0;
my $release;

my %opts = ();

getopts('vrlnV:', \%opts);

if ($opts{v}) {
  $verbose = 1;
}

if ($opts{l}) {
  $load_last = 1;
}

if ($opts{r}) {
  $restart = 1;
}

if ($opts{n}) {
  $dry_run = 1;
}

if ($opts{V}) {
  $release=$opts{V};
  push @ant_command, "-Drelease=$release"
}

if (@ARGV == 2) {
  $dump_host = $ARGV[0];
  $dump_file_prefix = $ARGV[1];
} else {
  usage;
}

my $log_file = "pbuild.log";

open LOG, ">>$log_file" or die "can't open $log_file: $!\n";
my $old_handle = select(LOG);
$| = 1; # autoflush
select $old_handle;

my $current_directory = (getcwd() =~ m:.*/(.*):)[0];

my $properties_file = "$ENV{HOME}/$current_directory.properties";
if (defined $release) {
  $properties_file .= ".$release";
}

my @dump_command = qw[pg_dump -c];
my @psql_command = qw[psql -q];

sub log_message
{
  my $message = shift;
  my $verbose = shift;

  if (defined $message) {
    print LOG "$message\n";
    if (defined $verbose && $verbose) {
      print STDERR "$message\n";
    }
  } else {
    print LOG "\n";
  }
}

sub log_and_print
{
  log_message shift, 1;
}

# run a command and exit the script if it returns a non-zero
sub run_and_check_status
{
  my $command_name = $_[0];

  log_and_print `date`, "\n\n";
  log_and_print "starting command: @_\n";

  my $result = 0;

  if (!$dry_run) {
    open F, "@_ |" or die "can't run @_: $?\n";

    while (<F>) {
      chomp;
      log_message "  [$command_name] $_";
    }

    close F;

    $result = $?;
  }

  log_and_print `date`, "\n\n";
  log_and_print "finished\n\n";

  warn "ERROR: $result\n";

  if (!$dry_run && $result != 0) {
    log_and_print "failed with exit code $?: @_\n";
    print STDERR "check log: $log_file\n";
    exit $?;
  }
}

# gets a value from a properties file
# usages: get_prop_val prop_name file_name
sub get_prop_val
{
  my $key = shift;
  my $file = shift;

  open F, "$file" or die "cannot open $file: $!\n";

  my $ret_val;

  while (my $line = <F>) {
    if ($line =~ /$key=(.*)/) {
      $ret_val = $1;
    }
  }

  close F;

  return $ret_val;
}

sub dump_db
{
  my $db = shift;
  my $user = shift;
  my $pass = shift;
  my $host = shift;
  my $port = shift;
  my $out_file = shift;

  my @params = ('-U', $user, '-h', $host, '-W', '-f', $out_file, $db);

  if (defined $port) {
    unshift @params, "-p", $port;
  }

  log_and_print `date`, "\n\n";
  log_and_print "\ndumping: @dump_command @params\n";

  my @spawn_args = ("@dump_command @params; echo __DUMP_FINISHED__");

  if ($dump_host eq 'localhost') {
    @spawn_args = "sh -c '@spawn_args'";
  } else {
    unshift @spawn_args, "ssh", $dump_host;
  }

  if ($dry_run) {
    log_and_print "command to run: @spawn_args\n";
  } else {
    my $exp = new Expect;

    $exp->raw_pty(1);
    $exp->spawn(@spawn_args)
      or die "Cannot spawn @dump_command @params: $!\n";

    $exp->expect(10, 'Password: ');
    $exp->send("$pass\n");
    $exp->expect(9999999, '__DUMP_FINISHED__\n');
    $exp->soft_close();
  }

  log_and_print `date`, "\n\n";
  log_and_print "finished dump\n\n";
}

sub load_db
{
  my $db = shift;
  my $user = shift;
  my $pass = shift;
  my $host = shift;
  my $port = shift;
  my $in_file = shift;

  my @params = ('-U', $user, '-h', $host, '-f', $in_file, $db);

  if (defined $port) {
    unshift @params, "-p", $port;
  }

  log_and_print `date`, "\n\n";
  log_and_print "\nrunning: @psql_command @params\n";
  warn "(ignore password prompt)\n";

  my @spawn_args = ("@psql_command @params; echo __LOAD_FINISHED__");

  if ($dump_host eq 'localhost') {
    $ENV{PAGER} = "/bin/cat";
    @spawn_args = "sh -c '@spawn_args'";
  } else {
    unshift @spawn_args, "ssh", $dump_host;
  }

  if ($dry_run) {
    log_and_print "command to run: @spawn_args\n";
  } else {
    my $exp = new Expect;

    $exp->raw_pty(1);

    $exp->spawn(@spawn_args)
      or die "Cannot spawn @psql_command @params: $!\n";

    $exp->expect(10, 'Password: ');
    $exp->send("$pass\n");
    $exp->expect(9999999, '__LOAD_FINISHED__\n');
    $exp->soft_close();
  }

  log_and_print `date`, "\n\n";
  log_and_print "finished load - now analysing\n\n";

  my $saved_dir = getcwd;
  chdir "$saved_dir/dbmodel" or die "can't change directory into: $saved_dir/dbmodel\n";

  run_and_check_status @ant_command, "analyse-db-production";

  chdir $saved_dir
    or die "can't return to previous directory ($saved_dir) after $saved_dir/dbmodel\n";

  log_and_print `date`, "\n\n";
  log_and_print "finished analysing\n\n";
}

package ProjectXML::Hander;

use vars qw{ $AUTOLOAD };

sub new {
  my $type = shift;
  my $self = ( $#_ == 0 ) ? shift : { @_ };

  $self->{sources} = [];
  return bless $self, $type;
}

sub start_element
{
  my $self = shift;
  my $args = shift;

  my $element_name = $args->{Name};
  my $action_name = $args->{Attributes}{name};
  my $dump_flag = exists $args->{Attributes}{dump};
  my $index_flag = exists $args->{Attributes}{index};

  if ($element_name eq 'source') {
    push @{$self->{actions}}, {
                               type => 'integrate',
                               args => ["-Dsource=$action_name"]
                              };
  } else {
    if ($element_name eq 'post-process') {
      push @{$self->{actions}}, {
                                 type => 'postprocess',
                                 args => ["-Daction=$action_name"]
                                };
    } else {
      return;
    }
  }

  if ($dump_flag) {
    push @{$self->{actions}}, {
                              type => 'dump',
                              args => ["$action_name"]
                             };
  }

  if ($index_flag) {
    push @{$self->{actions}}, {
                               type => 'index',
                               args => ["$action_name"]
                              };
  }
}

sub processing_instruction { }
sub ignorable_whitespace { }

# Others
sub AUTOLOAD {
    my $self = shift;

    my $method = $AUTOLOAD;
    $method =~ s/.*:://;
    return if $method eq 'DESTROY';

    print "UNRECOGNIZED $method\n";
}

1;


package main;

sub get_actions
{
  my $handler = ProjectXML::Hander->new();
  my $parser = XML::Parser::PerlSAX->new(Handler => $handler);

  $parser->parse(Source => { SystemId => $project_file });

  my @actions = @{$handler->{actions}};

  if (@actions && $actions[-1]{type} ne 'dump') {
    push @actions, {
                    type => 'dump',
                    args => ["final"]
                   };
  }

  return @actions;
}

# find the last existing dump file
sub get_restart_dump_suffix
{
  my ($dump_file_prefix, @actions) = @_;

  my %remote_suffixes = ();

  my $command;

  if ($dump_host eq 'localhost') {
    $command = qq{ls -1 $dump_file_prefix.*};
  } else {
    $command = qq{ssh $dump_host "ls -1 $dump_file_prefix.*"};
  }

  open LS_OUTPUT, qq{$command|};

  while (my $line = <LS_OUTPUT>) {
    chomp $line;
    if ($line =~ /$dump_file_prefix.(.*)/) {
      $remote_suffixes{$1} = 1;
    }
  }

  my $restart_dump_suffix = undef;

  for my $action (@actions) {
    my $action_type = $action->{type};
    my @action_args = @{$action->{args}};

    if ($action_type eq 'dump') {
      if (exists $remote_suffixes{$action_args[0]}) {
        $restart_dump_suffix = $action_args[0];
      }
    }
  }

  close LS_OUTPUT;

  return $restart_dump_suffix;
}

log_and_print "reading properties from: $properties_file\n";

my $prod_host = get_prop_val "db.production.datasource.serverName", $properties_file;
my $prod_db = get_prop_val "db.production.datasource.databaseName", $properties_file;
my $prod_user = get_prop_val "db.production.datasource.user", $properties_file;
my $prod_pass = get_prop_val "db.production.datasource.password", $properties_file;
my $prod_port;

if ($prod_host =~ /(.+):(\d+)/) {
  $prod_host = $1;
  $prod_port = $2;
}

log_message "read properties:";
log_message "  prod_host: $prod_host";
log_message "  prod_port: " . (defined($prod_port) ? $prod_port : "default");
log_message "  prod_db: $prod_db";
log_message "  prod_user: $prod_user";
log_message "  prod_pass: $prod_pass";
log_message;

my @actions = get_actions();

my $restart_dump_suffix = undef;

if ($load_last || $restart) {
  $restart_dump_suffix = get_restart_dump_suffix($dump_file_prefix, @actions);

  if (defined $restart_dump_suffix) {
    my $dump_file_name = "$dump_file_prefix.$restart_dump_suffix";

    if ($load_last) {
      log_and_print "\nrestarting from $dump_file_name\n";
      load_db $prod_db, $prod_user, $prod_pass, $prod_host, $prod_port, $dump_file_name;
    } else {
      log_and_print "\nrestarting build at stage: $restart_dump_suffix - NOT loading dump\n";
    }
  } else {
    warn "no dump file found with prefix $dump_file_prefix\n";
  }
}

my $seen_start_action = 0;

if ((!$load_last && !$restart) || !defined $restart_dump_suffix) {
  # always start at the beginning of the command list if we aren't restarting
  $seen_start_action = 1;
}

for my $action (@actions) {
  my $action_type = $action->{type};
  my @action_args = @{$action->{args}};

  if ($seen_start_action) {
    if ($action_type eq 'integrate' || $action_type eq 'postprocess') {
      my $saved_dir = getcwd;
      chdir $action_type
        or die "can't change directory into: $saved_dir/$action_type\n";
      if ($verbose) {
        run_and_check_status @ant_command, "-v", @action_args;
      } else {
        run_and_check_status @ant_command, @action_args;
      }
      chdir $saved_dir
        or die "can't return to previous directory ($saved_dir) after $action_type\n";
    } else {
      if ($action_type eq 'dump') {
        if (@action_args != 1) {
          die "dump: needs one parameter at: $action: @action_args\n";
        }
        dump_db $prod_db, $prod_user, $prod_pass, $prod_host, $prod_port,
                "$dump_file_prefix.$action_args[0]";
      } else {
        die qq{unknown action: "$action_type"\n};
      }
    }
  } else {
    if ($action_type eq 'dump' && $action_args[0] eq $restart_dump_suffix) {
      $seen_start_action = 1;
    }
  }
}

