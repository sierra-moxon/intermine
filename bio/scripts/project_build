#!/usr/bin/perl

# Run the FlyMine production build and dump the database occasionally
# Targets are listed at the end of the script
# The database to dump will be found by reading the properties from $HOME/<mine_name>.properties

use strict;
use warnings;

use Expect;
use Getopt::Std;
use Cwd;

use XML::Parser::PerlSAX;

my @ant_command = ("ant");

my $dump_file_prefix;
my $dump_host;
my $project_file = 'project.xml';

sub usage
{
  die <<"EOF";
usage:
  $0 [-v] [-l | -r] [-V <version>] [-a <actions>] dump_host dump_file_prefix

flags:
 -v is passed to ant
 -l attempt to restart by reading the last dump file
 -r attempt to restart just after the last dump point _without_ loading a dump
 -n parse files and report actions, but don't execute anything
 -V set the release number to pass to ant (as -Drelease=release_number)
 -a set the list of actions to perform - the list must be a subset of the
    sources/postprocesses in the project.xml file.
     - The -l and -r operate as usual.
     - To run all steps starting at <some_action> use a dash after the action
       name: -a <some_action>-
     - To perform only the final dump use: -a final-dump
     - To refer to dump step and skip its corresponding action use the action
       name with "-dump" appended
          eg -a fly-fish-dump-
             -a fly-fish-dump,flymine-static,create-utr-references,final-dump

example:
  $0 gollum /tmp/production_dump
EOF
}

if (!-f $project_file) {
  warn "can't find $project_file in the current directory\n";
  usage();
}

my $verbose = 0;
my $load_last = 0;
my $restart = 0;
my $dry_run = 0;
my $release;
my @required_actions_list = ();
my $start_action = undef;

my %opts = ();

getopts('vrlna:V:', \%opts);

if ($opts{v}) {
  $verbose = 1;
}

if ($opts{l}) {
  $load_last = 1;
}

if ($opts{r}) {
  $restart = 1;
}

if ($opts{n}) {
  $dry_run = 1;
}

if (exists $opts{a}) {
  my $arg = $opts{a};
  if ($arg =~ /^.*,.*-$/) {
    warn "error: can't use commas and '-' in -a <actions> argument: $arg\n";
    usage;
  }
  if ($arg =~ /(.*)-$/) {
    $start_action = $1;
  } else {
    @required_actions_list = split (',', $arg);
  }
}

if ($opts{V}) {
  $release=$opts{V};
  push @ant_command, "-Drelease=$release"
}

if (@ARGV == 2) {
  $dump_host = $ARGV[0];
  $dump_file_prefix = $ARGV[1];
} else {
  usage;
}

my $log_file = "pbuild.log";

open LOG, ">>$log_file" or die "can't open $log_file: $!\n";
my $old_handle = select(LOG);
$| = 1; # autoflush
select $old_handle;

my $current_directory = (getcwd() =~ m:.*/(.*):)[0];

my $properties_file = "$ENV{HOME}/$current_directory.properties";
if (defined $release) {
  $properties_file .= ".$release";
}

my @dump_command = qw[pg_dump -F c -i];
my @load_command = qw[pg_restore -1 -i];
my @dropdb_command = qw[dropdb];
my @createdb_command = qw[createdb -E SQL_ASCII];

sub log_message
{
  my $message = shift;
  my $verbose = shift;

  if (defined $message) {
    print LOG "$message\n";
    if (defined $verbose && $verbose) {
      print STDERR "$message\n";
    }
  } else {
    print LOG "\n";
  }
}

sub log_and_print
{
  log_message shift, 1;
}

# run a command and exit the script if it returns a non-zero
sub run_and_check_status
{
  my $command_name = $_[0];

  log_and_print `date`, "\n\n";
  log_and_print "starting command: @_\n";

  my $result = 0;

  if (!$dry_run) {
    open F, "@_ |" or die "can't run @_: $?\n";

    while (<F>) {
      chomp;
      log_message "  [$command_name] $_";
    }

    close F;

    $result = $?;
  }

  log_and_print `date`, "\n\n";
  log_and_print "finished\n\n";

  warn "ERROR: $result\n";

  if (!$dry_run && $result != 0) {
    log_and_print "failed with exit code $?: @_\n";
    print STDERR "check log: $log_file\n";
    exit $?;
  }
}

# gets a value from a properties file
# usages: get_prop_val prop_name file_name
sub get_prop_val
{
  my $key = shift;
  my $file = shift;

  open F, "$file" or die "cannot open $file: $!\n";

  my $ret_val;

  while (my $line = <F>) {
    if ($line =~ /^\s*#/) {
      next;
    }
    if ($line =~ /$key=(.*)/) {
      $ret_val = $1;
    }
  }

  close F;

  return $ret_val;
}

sub spawn
{
  my $pass = shift;
  my @spawn_args = @_;

  if ($dump_host eq 'localhost') {
    $ENV{PAGER} = "/bin/cat";
    @spawn_args = "sh -c '@spawn_args'";
  } else {
    unshift @spawn_args, "ssh", $dump_host;
  }

  if ($dry_run) {
    log_and_print "command to run: @spawn_args\n";
  } else {
    my $exp = new Expect;

    $exp->raw_pty(1);
    $exp->spawn("@spawn_args; echo __FINISHED__")
      or die "Cannot spawn @spawn_args: $!\n";

    $exp->expect(10, 'Password: ');
    $exp->send("$pass\n");
    $exp->expect(9999999,
                 [qr/error/i, sub {die "Error returned by @spawn_args\n"}],
                 "__FINISHED__\n");
    $exp->soft_close();
  }
}

sub dump_db
{
  my $db = shift;
  my $user = shift;
  my $pass = shift;
  my $host = shift;
  my $port = shift;
  my $out_file = shift;

  my @params = ('-U', $user, '-h', $host, '-W', '-f', $out_file, $db);

  if (defined $port) {
    unshift @params, "-p", $port;
  }

  log_and_print `date`, "\n\n";
  log_and_print "\ndumping: @dump_command @params\n";

  my @spawn_args = ($pass, "@dump_command @params");

  spawn(@spawn_args);

  log_and_print `date`, "\n\n";
  log_and_print "finished dump\n\n";
}

sub load_db
{
  my $db = shift;
  my $user = shift;
  my $pass = shift;
  my $host = shift;
  my $port = shift;
  my $in_file = shift;

  my @params = ('-U', $user, '-h', $host);

  if (defined $port) {
    unshift @params, "-p", $port;
  }

  log_and_print `date`, "\n\n";
  log_and_print "\nrunning: @dropdb_command @params $db\n";
  warn "(ignore password prompt)\n";

  spawn($pass, @dropdb_command, @params, $db);

  log_and_print `date`, "\n\n";
  log_and_print "\nrunning: @createdb_command @params $db\n";
  warn "(ignore password prompt)\n";

  spawn($pass, @createdb_command, @params, $db);

  push @params, '-d', $db, $in_file;

  log_and_print `date`, "\n\n";
  log_and_print "\nrunning: @load_command @params\n";
  warn "(ignore password prompt)\n";

  spawn($pass, @load_command, @params);

  log_and_print `date`, "\n\n";
  log_and_print "finished load - now analysing\n\n";

  my $saved_dir = getcwd;
  chdir "$saved_dir/dbmodel" or die "can't change directory into: $saved_dir/dbmodel\n";

  run_and_check_status @ant_command, "analyse-db-production";

  chdir $saved_dir
    or die "can't return to previous directory ($saved_dir) after $saved_dir/dbmodel\n";

  log_and_print `date`, "\n\n";
  log_and_print "finished analysing\n\n";
}

package ProjectXML::Hander;

use vars qw{ $AUTOLOAD };

sub new {
  my $type = shift;
  my $self = ( $#_ == 0 ) ? shift : { @_ };

  $self->{sources} = [];
  return bless $self, $type;
}

sub start_element
{
  my $self = shift;
  my $args = shift;

  my $element_name = $args->{Name};
  my $action_name = $args->{Attributes}{name};
  my $dump_flag = exists $args->{Attributes}{dump};
  my $index_flag = exists $args->{Attributes}{index};

  if ($element_name eq 'source') {
    push @{$self->{actions}}, {
                               type => 'integrate',
                               args => ["-Dsource=$action_name"],
                               name => $action_name
                              };
  } else {
    if ($element_name eq 'post-process') {
      push @{$self->{actions}}, {
                                 type => 'postprocess',
                                 args => ["-Daction=$action_name"],
                                 name => $action_name
                                };
    } else {
      return;
    }
  }

  if ($dump_flag) {
    push @{$self->{actions}}, {
                               type => 'dump',
                               args => ["$action_name"],
                               name => "$action_name-dump"
                             };
  }

  if ($index_flag) {
    push @{$self->{actions}}, {
                               type => 'index',
                               args => ["$action_name"],
                               name => "$action_name-index"
                              };
  }
}

sub processing_instruction { }
sub ignorable_whitespace { }

# Others
sub AUTOLOAD {
    my $self = shift;

    my $method = $AUTOLOAD;
    $method =~ s/.*:://;
    return if $method eq 'DESTROY';

    print "UNRECOGNIZED $method\n";
}

1;


package main;

sub get_actions
{
  my $handler = ProjectXML::Hander->new();
  my $parser = XML::Parser::PerlSAX->new(Handler => $handler);

  $parser->parse(Source => { SystemId => $project_file });

  my @actions = @{$handler->{actions}};

  if (@actions && $actions[-1]{type} ne 'dump') {
    push @actions, {
                    type => 'dump',
                    args => ["final"],
                    name => 'final-dump'
                   };
  }

  my @return_actions = ();

  if (defined $start_action) {
    my $seen_start = 0;

    # remove all before start_action
    for my $action (@actions) {
      if ($seen_start || $action->{name} eq $start_action) {
        push @return_actions, $action;
        $seen_start = 1;
      }
    }

    if (!$seen_start) {
      warn "error: start action $start_action not found in $project_file\n";
      usage;
    }
  } else {
    my @actions_not_found = @required_actions_list;

    if (@required_actions_list) {
      my %action_map = map {($_->{name}, $_)} @actions;

      # remove all not in required list
      for my $req_action_name (@required_actions_list) {
        if (exists $action_map{$req_action_name}) {
          push @return_actions, $action_map{$req_action_name};
        } else {
          die qq(no such action "$req_action_name" - from -a option);
        }
      }

      if (!@return_actions) {
        warn "error:  not found in $project_file\n";
        usage;
      }
    } else {
      # default - use all actions from project.xml
      @return_actions = @actions;
    }
  }

  return @return_actions;
}

# find the last existing dump file
sub get_restart_dump_suffix
{
  my ($dump_file_prefix, @actions) = @_;

  my %remote_suffixes = ();

  my $command;

  if ($dump_host eq 'localhost') {
    $command = qq{ls -1 $dump_file_prefix.*};
  } else {
    $command = qq{ssh $dump_host "ls -1 $dump_file_prefix.*"};
  }

  open LS_OUTPUT, qq{$command|};

  while (my $line = <LS_OUTPUT>) {
    chomp $line;
    if ($line =~ /$dump_file_prefix.(.*)/) {
      $remote_suffixes{$1} = 1;
    }
  }

  my $restart_dump_suffix = undef;

  for my $action (@actions) {
    my $action_type = $action->{type};
    my @action_args = @{$action->{args}};

    if ($action_type eq 'dump') {
      if (exists $remote_suffixes{$action_args[0]}) {
        $restart_dump_suffix = $action_args[0];
      }
    }
  }

  close LS_OUTPUT;

  return $restart_dump_suffix;
}

log_and_print "reading properties from: $properties_file\n";

my $prod_host = get_prop_val "db.production.datasource.serverName", $properties_file;
my $prod_db = get_prop_val "db.production.datasource.databaseName", $properties_file;
my $prod_user = get_prop_val "db.production.datasource.user", $properties_file;
my $prod_pass = get_prop_val "db.production.datasource.password", $properties_file;
my $prod_port;

if ($prod_host =~ /(.+):(\d+)/) {
  $prod_host = $1;
  $prod_port = $2;
}

log_message "read properties:";
log_message "  prod_host: $prod_host";
log_message "  prod_port: " . (defined($prod_port) ? $prod_port : "default");
log_message "  prod_db: $prod_db";
log_message "  prod_user: $prod_user";
log_message "  prod_pass: $prod_pass";
log_message;

my @actions = get_actions();

my $restart_dump_suffix = undef;

if ($load_last || $restart) {
  $restart_dump_suffix = get_restart_dump_suffix($dump_file_prefix, @actions);

  if (defined $restart_dump_suffix) {
    my $dump_file_name = "$dump_file_prefix.$restart_dump_suffix";

    if ($load_last) {
      log_and_print "\nrestarting from $dump_file_name\n";
      load_db $prod_db, $prod_user, $prod_pass, $prod_host, $prod_port, $dump_file_name;
    } else {
      log_and_print "\nrestarting build at stage: $restart_dump_suffix - NOT loading dump\n";
    }
  } else {
    warn "no dump file found with prefix $dump_file_prefix\n";
  }
}

my $seen_start_action = 0;

if ((!$load_last && !$restart) || !defined $restart_dump_suffix) {
  # always start at the beginning of the command list if we aren't restarting
  $seen_start_action = 1;
}

my @action_times = ();

for my $action (@actions) {
  my $action_type = $action->{type};
  my @action_args = @{$action->{args}};

  if ($seen_start_action) {
    my $start_time = time();

    if ($action_type eq 'integrate' || $action_type eq 'postprocess') {
      my $saved_dir = getcwd;
      chdir $action_type
        or die "can't change directory into: $saved_dir/$action_type\n";
      if ($verbose) {
        run_and_check_status @ant_command, "-v", @action_args;
      } else {
        run_and_check_status @ant_command, @action_args;
      }
      chdir $saved_dir
        or die "can't return to previous directory ($saved_dir) after $action_type\n";
    } else {
      if ($action_type eq 'dump') {
        if (@action_args != 1) {
          die "dump: needs one parameter at: $action: @action_args\n";
        }
        dump_db $prod_db, $prod_user, $prod_pass, $prod_host, $prod_port,
                "$dump_file_prefix.$action_args[0]";
      } else {
        die qq{unknown action: "$action_type"\n};
      }
    }

    my $end_time = time();
    my $action_time = $end_time - $start_time;

    my $action_name = $action->{name};

    if ($verbose) {
      log_and_print qq(action $action_name took $action_time seconds\n);
    }

    push @action_times, [$action_name, $action_time];
  } else {
    if ($action_type eq 'dump' && $action_args[0] eq $restart_dump_suffix) {
      $seen_start_action = 1;
    }
  }
}

my ($key, $value);

format STDOUT_TOP =

action name                             time in seconds
-------------------------------------------------------
.

format STDOUT =
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< @>>>>>>>>>>>>>
$key, $value
.

my $total_time = 0;

for my $name_and_time (@action_times) {
  ($key, $value) = @$name_and_time;
  $total_time += $value;
  write;
}

print "\n";

$key = 'total';
$value = $total_time;
write;
